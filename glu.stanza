;; See license.txt for details about licensing.

defpackage glu :
  import core
  import collections
  import gl
  import geom

val GLU-TESS-BEGIN =                     100100
val GLU-BEGIN =                          100100
val GLU-TESS-VERTEX =                    100101
val GLU-VERTEX =                         100101
val GLU-TESS-END =                       100102
val GLU-END =                            100102
val GLU-TESS-ERROR =                     100103
val GLU-TESS-EDGE-FLAG =                 100104
val GLU-EDGE-FLAG =                      100104
val GLU-TESS-COMBINE =                   100105
val GLU-TESS-BEGIN-DATA =                100106
val GLU-TESS-VERTEX-DATA =               100107
val GLU-TESS-END-DATA =                  100108
val GLU-TESS-ERROR-DATA =                100109
val GLU-TESS-EDGE-FLAG-DATA =            100110
val GLU-TESS-COMBINE-DATA =              100111
val GL-DEPTH-COMPONENT =                 6402 ;; 0x1902

extern glGetDoublev: (int, ptr<double>) -> int
extern glGetIntegerv: (int, ptr<int>) -> int

extern gluNewTess: () -> ptr<?>
extern gluDeleteTess: (ptr<?>) -> int
extern gluTessBeginPolygon: (ptr<?>, int) -> int
extern gluTessEndPolygon: (ptr<?>) -> int
extern gluTessBeginContour: (ptr<?>) -> int
extern gluTessEndContour: (ptr<?>) -> int
extern gluTessVertex: (ptr<?>, ptr<double>, int) -> int
extern gluTessCallback: (ptr<?>, int, ptr<((? ...) -> int)>) -> int
extern gluPerspective: (double, double, double, double) -> int
extern gluProject: (double, double, double, ptr<double>, ptr<double>, ptr<int>, ptr<double>, ptr<double>, ptr<double>) -> int
extern glReadPixels: (int, int, int, int, int, int, ptr<?>) -> int
extern gluUnProject: (double, double, double, ptr<double>, ptr<double>, ptr<int>, ptr<double>, ptr<double>, ptr<double>) -> int
extern gluOrtho2D: (double, double, double, double) -> int
extern printf: (? ...) -> int
extern malloc: (long) -> ptr<?>

defstruct TessMesh :
  indices: Vector<Int>
  vertices: Vector<V3f>

val meshes = Vector<TessMesh>()

lostanza deftype Tess :
  value: ptr<?>

lostanza defn glu-new-tess () -> ref<Tess> :
  return new Tess{ call-c gluNewTess() }
  
lostanza defn glu-delete-tess (tess:ref<Tess>) -> ref<False> :
  call-c gluDeleteTess(tess.value)
  return false

lostanza defn glu-tess-begin-polygon (tess:ref<Tess>, mesh:ref<Int>) -> ref<False> :
  call-c gluTessBeginPolygon(tess.value, mesh.value)
  return false

lostanza defn glu-tess-end-polygon (tess:ref<Tess>) -> ref<False> :
  call-c gluTessEndPolygon(tess.value)
  return false

lostanza defn glu-tess-begin-contour (tess:ref<Tess>) -> ref<False> :
  call-c gluTessBeginContour(tess.value)
  return false

lostanza defn glu-tess-end-contour (tess:ref<Tess>) -> ref<False> :
  call-c gluTessEndContour(tess.value)
  return false

lostanza defn glu-tess-vertex (tess:ref<Tess>, vertex:ref<V3d>, size:ref<Int>) -> ref<False> :
  call-c gluTessVertex(tess.value, addr!(vertex.x), size.value)
  return false

lostanza defn glu-tess-callback (tess:ref<Tess>, kind:ref<Int>, fun:ptr<((? ...) -> int)>) -> ref<False> :
  call-c gluTessCallback(tess.value, kind.value, fun)
  return false

extern defn begin_callback (type: int, mesh: ref<Int>) -> int :
  return 0

extern defn edge_flag_callback (index: int, mesh: ref<Int>) -> int :
  return 0

extern defn vertex_callback (index: int, mesh-index: ref<Int>) -> int :
  val mesh = get(meshes, mesh-index)
  add(indices(mesh), new Int{ index })
  return 0

extern defn end_callback (mesh: ref<Int>) -> int :
  return 0

extern defn error_callback (errno: int, mesh: ref<Int>) -> int :
  return 0

extern defn combine_callback (coords: ptr<double>, vertexData: ptr<int>, weight: ptr<float>, outData: ptr<int>, mesh-index: ref<Int>) -> int :
  val mesh = get(meshes, mesh-index)
  add(vertices(mesh), V3f(new Float{ coords[0] as float }, new Float{ coords[1] as float }, new Float{ coords[2] as float }))
  return length(vertices(mesh)).value - 1

lostanza defn FabTess () -> ref<Tess> :
  val t = new Tess{ call-c gluNewTess() }
  glu-tess-callback(t, GLU-TESS-BEGIN-DATA, addr(begin_callback))
  glu-tess-callback(t, GLU-TESS-EDGE-FLAG-DATA, addr(edge_flag_callback))
  glu-tess-callback(t, GLU-TESS-VERTEX-DATA, addr(vertex_callback))
  glu-tess-callback(t, GLU-TESS-END-DATA, addr(end_callback))
  glu-tess-callback(t, GLU-TESS-COMBINE-DATA, addr(combine_callback))
  glu-tess-callback(t, GLU-TESS-ERROR-DATA, addr(error_callback))
  return t

public defn triangulate (poly:Polygon) -> Mesh :
  val tess = FabTess()
  val mesh = TessMesh(Vector<Int>(), Vector<V3f>())
  val index = length(meshes)
  add(meshes, mesh)
  glu-tess-begin-polygon(tess, index)
  for c in contours(poly) do :
    glu-tess-begin-contour(tess)
    for p in vertices(c) do :
      add(vertices(mesh), xyz(p))
      glu-tess-vertex(tess, to-v3d(xyz(p)), length(vertices(mesh)) - 1)
    glu-tess-end-contour(tess)
  glu-tess-end-polygon(tess)
  glu-delete-tess(tess)
  pop(meshes)
  val faces = Vector<V3i>()
  for i in 0 to length(indices(mesh)) / 3 do :
    add(faces, V3i(indices(mesh)[i * 3], indices(mesh)[i * 3 + 2], indices(mesh)[i * 3 + 1]))
  Mesh(to-tuple(vertices(mesh)), to-tuple(faces))

public lostanza defn glu-perspective (a:ref<Float>, b:ref<Float>, c:ref<Float>, d:ref<Float>) -> ref<False> :
  call-c gluPerspective(a.value as double, b.value as double, c.value as double, d.value as double)
  return false

lostanza val *model* : ptr<double> = call-c malloc(16 * sizeof(double))
lostanza val *proj* : ptr<double> = call-c malloc(16 * sizeof(double))
lostanza val *view* : ptr<int>  = call-c malloc(4 * sizeof(int))
lostanza val *ptx* : ptr<double> = call-c malloc(1 * sizeof(double))
lostanza val *pty* : ptr<double> = call-c malloc(1 * sizeof(double))
lostanza val *ptz* : ptr<double> = call-c malloc(1 * sizeof(double))

lostanza defn load-project-data () -> ref<False> :
  call-c glGetDoublev( GL-MODELVIEW-MATRIX.value, *model* )
  call-c glGetDoublev( GL-PROJECTION-MATRIX.value, *proj* )
  call-c glGetIntegerv( GL-VIEWPORT.value, *view* )
  return false

public lostanza defn glu-project (obj:ref<V3f>) -> ref<V3f> :
  load-project-data()
  call-c gluProject(x(obj).value as double, y(obj).value as double, z(obj).value as double,
                    *model*, *proj*, *view*, *ptx*, *pty*, *ptz*)
  return new V3f{[*ptx*] as float, [*pty*] as float, [*ptz*] as float}

public defn glu-project-dims (dims:V3f) -> Box3f :
  Box3f(glu-project(-0.5f * dims), glu-project(0.5f * dims))

lostanza val *win-z* : ptr<float> = call-c malloc(1 * sizeof(float))

public lostanza defn glu-unproject (win:ref<V3i>, win-z:ref<Float>) -> ref<V3f> :
  load-project-data()
  val win-y = *view*[3] - y(win).value
  call-c gluUnProject(x(win).value as double, win-y as double, win-z.value as double,
                      *model*, *proj*, *view*, *ptx*, *pty*, *ptz*)
  return new V3f{[*ptx*] as float, [*pty*] as float, [*ptz*] as float}

public lostanza defn glu-unproject (win:ref<V3i>) -> ref<V3f> :
  val win-y = *view*[3] - y(win).value
  call-c glReadPixels(x(win).value, win-y, 1, 1, GL-DEPTH-COMPONENT.value, GL-FLOAT.value, *win-z*)
  return glu-unproject(win, new Float{[*win-z*] as float})

;; public lostanza defn glu-unproject (x:Int, y:Int) -> ref<V3f> :
;;   load-project-data()
;;   val win-x = x
;;   call-c glReadPixels(x, win-y, 1, 1, GL-DEPTH-COMPONENT, GL-FLOAT, *win-z*)
;;   call-c gluUnProject(to-float(x), to-float(win-y), [*win-z*], *model*, *proj*, *view*, *ptx*, *pty*, *ptz*)
;;   return new V3f{[*ptx*] as float, [*pty*] as float, [*ptz*] as float}

public lostanza defn glu-ortho2d (l:ref<Float>, r:ref<Float>, b:ref<Float>, t:ref<Float>) -> ref<False> :
  call-c gluOrtho2D(l.value as double, r.value as double, b.value as double, t.value as double)
  return false


